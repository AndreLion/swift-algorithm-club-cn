# 大 O 表示法

知道一个算法的运行时间和占用空间，对于选出正确的算法来解决问题非常有帮助  

大 O 表示法能让你对一个算法的运行时间和占用空间有个大概概念。当有人说 “这个算法在最糟情况下的运行时间是**O(n^2)** 而且占用了 **O(n)** 大小的空间” 他的意思是这个算法蛮慢的，不过没占多大空间。   

要知道一个算法的大 O 表示法通常要通过数学分析。我们这里跳过具体的数学，不过知道不同的值意味着什么会很有用。所以这里有一张方便的表。 
**n** 在这里代表的意思是数据的个数。举个例子， 当排序一个有 100 个元素的数组时， **n = 100**。

Big-O | 名字 | 描述
------| ---- | -----------
**O(1)** | 常数级(constant) | **最好的** 不论输入数据是多少， 这个算法的运行时间总是一样的。例子: 根据索引找出数组中对应的元素。
**O(log n)** | 对数级(logarithmic) | **相当好** 这种算法每次循环时会把数据量减半。 如果你有 100 个元素 只需要 7 步就可以找到答案。 1000 个元素 只要 10 步。  100,0000 元素只要 20 步。 即便数据量很大这种算法也非常快。 例子: 二分查找
**O(n)** | 线性级(linear) | **好**  如果你有 100 个元素， 这种算法就要做 100 次工作。 数据量翻倍那么运行时间也翻倍。 例子: 线性查找
**O(n log n)** | 线性对数级(linearithmic) | **还行** 比线性级糟了一些， 不过也没那么差劲。 例子: 最快的通用排序算法。
**O(n^2)** | 二次方级(quadratic) | **蛮慢的** 如果你有 100 个元素， 这个要做 100^2 = 10000 次工作。 数据量 x 2 会导致运行时间 x 4 (因为 2  的 2 次方等于 4)。 例子: 循环套循环的算法， 比如插入排序
**O(n^3)** | 三次方级(cubic) | **慢** 如果你有 100 个元素， 那么它要做 100^3 = 100,0000 次工作。 数据量 x 2 会导致运行时间 x 8。 例子: 矩阵乘法。
**O(2^n)** | 指数级(exponential) | **慢死了** 这种算法你要想方设法避免， 但有时候你就是没得选。 加一点点数据就会把运行时间成倍的加长。 例子: 旅行商问题
**O(n!)** | 阶乘级(factorial) | **蜗牛慢** 不管干什么都要跑个 N 年才能得到结果  

大部分情况下你用直觉就可以知道一个算法的大 O 表示法。 如果你的代码用一个循环遍历你输入的每个元素， 那么这个算法就是 **O(n)**。   如果是循环套循环， 那就是 **O(n^2)**。 如果 3 个循环套在一起就是 **O(n^3)**， 以此类推   

注意， 大 O 表示法只是一种估算， 当数据量大的时候才有用。  举个例子， [插入排序](Insertion Sort/) 的最糟情况运行时间是 **O(n^2)**。 理论上来说它的运行时间比 [归并排序](Merge Sort/) 要慢。 归并排序是 **O(n log n)**。  
但对于小数据量， 插入排序实际上更快一些， 特别是那些数组里已经有一部分数据是排序好了的。  

如果你看完没懂， 别太上心。 当比较两种算法哪种好的时候大 O 表示法才有用。 最后你总是希望实际测试哪个才是最好的。 而且如果数据比较少， 哪怕算法比较慢， 实际使用也不会造成什么问题。    
